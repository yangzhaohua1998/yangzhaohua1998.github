<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vim学习笔记01</title>
      <link href="/2021/06/12/Vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
      <url>/2021/06/12/Vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim学习笔记01"><a href="#Vim学习笔记01" class="headerlink" title="Vim学习笔记01"></a>Vim学习笔记01</h1><p>Vim是一款<strong>扩展性强</strong>、<strong>高效</strong>、<strong>便捷</strong>的文本编辑器，熟练使用者可以把鼠标扔进垃圾桶。</p><p>然而其使用尤其是要达到熟练使用是需要一定的学习成本的。光是他五花八门的配置、丰富多彩的插件的使用就需要学习一段时间。更无奈的是，网上许多Vim的配置往往是把自己好几百行功能强大的配置文件甩你脸上，这份配置还极可能是张三复制李四，李四克隆王五的。即使配置好了也不知道怎么用。</p><p>以上是我在学习Vim过程中所苦恼的问题。在一下午的摸索学习中，总算是找到几个感觉不错的文档来学习Vim的快捷键？如何配置Vim？这两个基础问题。怕以后遗忘，将其记录在此篇博客中。</p><p>1、官方vimtutor</p><blockquote><p>首先是Vim基础的快捷键学习，建议使用vimtutor。在安装Vim之后，终端中输入 <code>vimtutor</code> 即可进入官方的学习文档。</p></blockquote><p>2、<a href="https://www.kancloud.cn/kancloud/learn-vimscript-the-hard-way/49321" target="_blank" rel="noopener">笨方法学Vimscript</a><br>大致分为三个部分：</p><blockquote><ul><li>第一部分讲述了一些Vim的基本命令，通过这些命令修改你的~/.vimrc可以快速、 方便地定制你的Vim环境</li><li>第二部分将Vimscript作为一门编程语言做深入了解，包括变量、比较还有函数。</li><li>第三部分实例创建一个插件。</li></ul></blockquote><p>3、<a href="https://vimjc.com/vimrc.html" target="_blank" rel="noopener">无插件Vim配置文件vimrc推荐与各VIM配置项解释</a></p><p>4、<a href="https://dougblack.io/words/a-good-vimrc.html" target="_blank" rel="noopener">A Good Vimrc</a></p><blockquote><p>There are tons of tutorials such as this one on the internet that contain all kinds of awesome hacks to make your Vim better, but the absolute worst way to make your environment better is to just copy it wholesale from others. </p></blockquote><p>5、<a href="https://github.com/wklken/vim-for-server" target="_blank" rel="noopener">vim-for-server</a></p><blockquote><p>一个规范带注释的.vimrc文件</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVM的学习与使用</title>
      <link href="/2021/05/20/lvm%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/05/20/lvm%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="LVM的学习与使用"><a href="#LVM的学习与使用" class="headerlink" title="LVM的学习与使用"></a>LVM的学习与使用</h1><h2 id="LVM的学习"><a href="#LVM的学习" class="headerlink" title="LVM的学习"></a>LVM的学习</h2><h3 id="LVM基础知识"><a href="#LVM基础知识" class="headerlink" title="LVM基础知识"></a>LVM基础知识</h3><p>LVM全称Logical Volume Manager（逻辑卷管理），通过将底层磁盘抽象封装，以逻辑卷的形式呈现给上层文件系统，是一种动态的磁盘管理机制。</p><pre><code>· PE(physical Extend) LVM中最小的单位，默认为4M大小。· PV(physical Volume) 物理卷，表示一个磁盘的抽象。一个磁盘进行条带化后，也就是将磁盘都划分为一个一个PE后，就变成一个PV了。· VG(Volume Group) 卷组，由PV组成。相当于一个PE池。· LV(Logical Volume) 基于VG创建。从VG管理的PE池中划分一定的PE组成LV。因此，可能存在一个LV中存在不同磁盘的PE。</code></pre><h3 id="创建LVM"><a href="#创建LVM" class="headerlink" title="创建LVM"></a>创建LVM</h3><p>1、将物理磁盘条带化为PV</p><pre><code>pvcreate /dev/sdb /dev/sdc</code></pre><p>2、创建卷组，并将PV加进卷组中</p><pre><code>vgcreate myvg /dev/sdb /dev/sdc</code></pre><p>3、基于卷组创建逻辑卷</p><pre><code>lvcreate -n mylv -L 2G myvg  参数：-n 对lv命名，-L 指定lv大小。</code></pre><p>4、为创建好的逻辑卷创建文件系统</p><pre><code>mkfs.ext4 /dev/myvg/mylv</code></pre><p>5、将格式化好的逻辑卷挂载到/mnt目录使用</p><pre><code>mount /dev/myvg/lv /mnt</code></pre><p>如下图所示：<br><img src="%5Cimages%5CLVM%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%5C%E5%88%9B%E5%BB%BAlv.png" alt="lvm管理系统"></p><h3 id="删除LVM"><a href="#删除LVM" class="headerlink" title="删除LVM"></a>删除LVM</h3><p>1、卸载LV</p><pre><code>umount /mnt</code></pre><p>2、删除LV</p><pre><code>lvremove /dev/myvg/mylv</code></pre><p>3、删除VG</p><pre><code>vgremove myvg</code></pre><p>4、删除物理卷</p><pre><code>pvremove /dev/sdb</code></pre><h3 id="LV的拉伸"><a href="#LV的拉伸" class="headerlink" title="LV的拉伸"></a>LV的拉伸</h3><p>LV拉伸操作可以<em>在线执行</em></p><p>1、保证VG有足够空闲空间</p><pre><code>vgdisplay</code></pre><p>2、扩充LV</p><pre><code>lvextend -L +1G /dev/myvg/mylv</code></pre><p>3、查看扩充后的LV大小</p><pre><code>lvdisplay</code></pre><p>4、更新文件系统</p><pre><code>resize2fs /dev/myvg/mylv</code></pre><p>5、查看更新后的文件系统</p><pre><code>df -h</code></pre><h3 id="VG的拉伸"><a href="#VG的拉伸" class="headerlink" title="VG的拉伸"></a>VG的拉伸</h3><p>1、将添加到VG的硬盘条状话为PV</p><pre><code>pvcreate /dev/sdd</code></pre><p>2、将新PV添加到指定卷组</p><pre><code>vgextend myvg /dev/sdd</code></pre><p>3、查看扩充后的VG大小</p><pre><code>vgdisplay</code></pre><h3 id="LV的缩小"><a href="#LV的缩小" class="headerlink" title="LV的缩小"></a>LV的缩小</h3><p>LV的缩小必须先卸载，<strong>无法在线执行</strong>。且此操作应慎重，当LV缩小后的容量比文件系统重设置后的容量小，则可能会损坏文件数据。如以下为将LV从19G缩容至10G：</p><p>1、卸载已经挂载的LV</p><pre><code>umount /mnt</code></pre><p>2、缩小文件系统为1G<br>(此命令将<strong>文件系统压缩为10G</strong>。且此命令执行前一般会让先校验文件系统)</p><pre><code>resize2fs /dev/myvg/mylv 10G</code></pre><p>3、缩小LV</p><pre><code>lvreduce -L -9G /dev/myvg/mylv</code></pre><p>4、查看缩小后的LV</p><pre><code>lvdisplay</code></pre><p>5、挂载</p><pre><code>mount /dev/myvg/mylv /mnt</code></pre><h3 id="VG的缩小"><a href="#VG的缩小" class="headerlink" title="VG的缩小"></a>VG的缩小</h3><p>常用在移除硬盘的前置操作。首先保证VG空闲空间比取走的硬盘空间容量大。</p><p>1、将一个PV从vg中抽走(如sdd盘)，减小vg空间</p><pre><code>vgreduce myvg /dev/sdd</code></pre><p>2、此时sdd还可以通过pv查看，但不属于任何vg</p><pre><code>pvremove /dev/sdd</code></pre><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>· 查看列出的分区表  <code>fdisk -l</code></p><p>· 查看 PV 信息 <code>pvdisplay(详细)</code>  <code>pvs(简略)</code></p><p>· 查看 VG 信息 <code>vgdisplay(详细)</code>  <code>vgs(简略)</code></p><p>· 查看 LV 信息 <code>lvdisplay(详细)</code>  <code>lvs(简略)</code></p><h2 id="LVM的使用"><a href="#LVM的使用" class="headerlink" title="LVM的使用"></a>LVM的使用</h2><p><strong>需求</strong>：将挂载到home下LV进行缩容，让出VG空闲600G。将两个300G的LV挂载到/var/lib/docker，和/srv。  </p><p>一、先对/home下的LV进行缩容<br>1、查看文件挂载情况<br>    <code>df -h</code><br>2、卸载/home下LV<br>    <code>umount /home</code><br>3、缩小home文件系统为3T<br>    <code>e2fsck -f /dev/mapper/openeuler-home</code>(检查文件系统)<br>    <code>resize2fs /dev/mapper/openeuler-home 3T</code>(文件系统重置为3T大小)<br>4、缩小LVhome1T的LV容量<br>    <code>lvreduce -L -1T /dev/mapper/openeuler-home</code>(home下lv缩小1T容量，理论上将原来4.3T的文件系统重置为了3T大小后，lv应缩容1.3T。但是为了为了保险起见只缩容了1T，但是不可以超过1.3T)<br>5、将LVhome挂载回<br>    <code>mount /dev/openeuler/home /home</code><br>二、创建LV并挂载到相应目录<br>1、创建两个300G的LV<br>    <code>lvcreate -n openeuler-srv -L 300G openeuler</code><br>    <code>lvcreate -n openeuler-var-lib-docker -L 300G openeuler</code><br>2、将两个LV进行文件系统格式化<br>    <code>mkfs.ext4 /dev/openeuler/openeuler-srv</code><br>    <code>mkfs.ext4 /dev/openeuler/openeuler-var-lib-docker</code>  </p><p>3、将两个LV分别挂载到/srv、/var/lib/docker<br>    <code>mount /dev/openeuler/openeuler-srv /srv</code><br>    <code>mount /dev/openeuler/openeuler-var-lib-docker /var/lib/docker</code>  </p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(04 day)恢复空格(Re-space)</title>
      <link href="/2020/07/11/04-day-%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC-Re-space/"/>
      <url>/2020/07/11/04-day-%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC-Re-space/</url>
      
        <content type="html"><![CDATA[<h1 id="04-day-恢复空格-Re-space"><a href="#04-day-恢复空格-Re-space" class="headerlink" title="(04 day)恢复空格(Re-space)"></a>(04 day)恢复空格(Re-space)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p><p>注意：本题相对原题稍作改动，只需返回未识别的字符数</p><p><strong>示例：</strong></p><p>输入：<br>dictionary = [“looked”,”just”,”like”,”her”,”brother”]<br>sentence = “jesslookedjustliketimherbrother”<br>输出： 7<br>解释： 断句后为”jess looked just like tim her brother”，共7个未识别字符。</p><p><strong>提示：</strong></p><p>0 &lt;= len(sentence) &lt;= 1000<br>dictionary中总字符数不超过 150000。<br>你可以认为dictionary和sentence中只包含小写字母。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题和之前的单词拆分思路类似，不过之前的那道题时间不够，对动态规划也不熟。看了答案后知道了要使用动态规划和哈希表。但是自己做动态规划的时候总是没有很明确的思路，还需要加强。而哈希表、字典树等只是数据结构的工具，理解掌握还是不难。</p><p><img src="%5Cimages%5CRe-spaceTrie.gif" alt="算法图示&lt;源于：LeetCode&gt;"></p><p>看到这图我就有思路了。用字典树将字典单词存起来（反向插入），用sentence的长度+1的dp数组保存每个字符的状态。走到i时，令j = i,让sentence[j]字符进字典树进行查找，存在则j–，sentence[j]进字典树继续查找，不存在则break，然后i++。如果能够查到完整单词也就是sentence[j]的状态isEnd==true，比较dp[i]和bp[j-1]谁小。其实我最开始理解的是直接交换不久好了为啥还要比较一下。后来有个示例没过发现了原因。比如</p><pre><code class="c">dictionary：abc，abcd，dfabcsentence：abcdfabc</code></pre><p>到最后一位c时，dp是这样的</p><pre><code class="c">     abcdfabc    01230123？</code></pre><p>此时进行字符匹配会先与abc匹配</p><pre><code class="c">     abcdfabc    012301231</code></pre><p>但是由于abc和dfabc存在公共子串abc，所以还会继续比较。如果没有fmin(dp[i], dp[j-1])，那么这种情况就是直接</p><pre><code class="c">     abcdfabc    012301233</code></pre><p>显然是不如abc匹配的结果。所以还是要加上fmin()进行比较的。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;/*    解题思路，动态规划+字典树。*/typedef struct Trie{    struct Trie *next[26];    bool isEnd;} Trie;bool init(Trie** T){    *T = (Trie *)malloc(sizeof(Trie));    if (!T)    {        return false;    }    (*T)-&gt;isEnd = false;    memset((*T)-&gt;next, NULL, sizeof((*T)-&gt;next));    return true;}void insert(Trie *T, char *dic){    int len = strlen(dic);    for (int i = len - 1; i &gt;= 0; i--)    {        int temp = dic[i] - &#39;a&#39;;        if (T-&gt;next[temp] == NULL)        {            init(&amp;(T-&gt;next[temp]));        }        T = T-&gt;next[temp];    }    T-&gt;isEnd = true;}int respace(char **dictionary, int dictionarySize, char *sentence){    int n = strlen(sentence);    Trie* T;    init(&amp;T);    for (int i = 0; i &lt; dictionarySize; i++)    {        insert(T, dictionary[i]);    }    int dp[n + 1];    memset(dp, -1, sizeof(dp));    dp[0] = 0;    for (int i = 1; i &lt;= n; i++)    {        dp[i] = dp[i - 1] + 1;        Trie* dicT = T;        for (int j = i; j &gt; 0; j--)        {            int temp = sentence[j - 1] - &#39;a&#39;;            if (dicT-&gt;next[temp] == NULL)//不存在该单词，break            {                break;            }            else if (dicT-&gt;next[temp]-&gt;isEnd)//到一个单词尾，将dp[i]更新，但不停止，可能存在更长的单词            {                dp[i] = fmin(dp[i], dp[j-1]);            }            if (dp[i] == 0)//前面没有单独字符            {                break;            }            dicT = dicT-&gt;next[temp];        }    }    return dp[n];}int main(){    int ans, dictionarySize;    char** dictionary;    char sentence[1000];    //printf(&quot;请输入字典单词个数：\n&quot;);    scanf(&quot;%d&quot;, &amp;dictionarySize);    dictionary = (char**)malloc(dictionarySize * sizeof(char*));    for (int i = 0; i &lt; dictionarySize; i++)    {        dictionary[i] = (char*)malloc(100*sizeof(char));    }    //printf(&quot;请输入%d个字典单词：\n&quot;, dictionarySize);    for (int i = 0; i &lt; dictionarySize; i++)    {        scanf(&quot;%s&quot;, dictionary[i]);    }    //printf(&quot;请输入判断的句子：\n&quot;);    scanf(&quot;%s&quot;, sentence);    printf(&quot;sentence: %s\n&quot;, sentence);    printf(&quot;ans = %d\n&quot;, respace(dictionary, dictionarySize, sentence));    printf(&quot;输入的字典单词有：\n&quot;);    for (int i = 0; i &lt; dictionarySize; i++)    {        printf(&quot;%s\n&quot;, dictionary[i]);    }}/*test:5lookedjustlikeherbrotherjesslookedjustliketimherbrother*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> median </tag>
            
            <tag> Trie </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(03 day)跳水板(diving board)</title>
      <link href="/2020/07/08/03-day-%E8%B7%B3%E6%B0%B4%E6%9D%BF-diving-board/"/>
      <url>/2020/07/08/03-day-%E8%B7%B3%E6%B0%B4%E6%9D%BF-diving-board/</url>
      
        <content type="html"><![CDATA[<h1 id="03-day-跳水板-divingBoard"><a href="#03-day-跳水板-divingBoard" class="headerlink" title="(03 day)跳水板(divingBoard)"></a>(03 day)跳水板(divingBoard)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p><p>返回的长度需要从小到大排列。</p><p><strong>示例：</strong></p><pre><code class="c">输入：shorter = 1longer = 2k = 3输出： {3,4,5,6}</code></pre><p>这道题比较简单的。自然而然的想到直接全选最短板。然后一块长板替换一块短板，以此类推。所有就全选最短板 + k个最短板依次换成最长板 = k+1次计算。</p><p>时间复杂度：<em>O ( k + 1 )</em></p><p><strong>代码如下：</strong></p><pre><code class="c">int *divingBoard(int shorter, int longer, int k, int *returnSize){    int *ans;    int size, dvalue;    if (k == 0)    {        *returnSize = 0;        return NULL;    }    else if (shorter == longer)    {        size = 1;        ans = (int *)malloc(sizeof(int));        ans[0] = k * shorter;        *returnSize = size;        return ans;    }    else    {        size = k + 1;        ans = (int *)malloc((k + 1) * sizeof(int));        dvalue = longer - shorter;        ans[0] = shorter * k;        for (int i = 1; i &lt; size; i++)        {            ans[i] = ans[i - 1] + dvalue;        }        *returnSize = k + 1;        return ans;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(02 day)路径求和(path sum)</title>
      <link href="/2020/07/08/02-day-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C-path-sum/"/>
      <url>/2020/07/08/02-day-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C-path-sum/</url>
      
        <content type="html"><![CDATA[<h1 id="02-day-路径求和-pathSum"><a href="#02-day-路径求和-pathSum" class="headerlink" title="(02 day)路径求和(pathSum)"></a>(02 day)路径求和(pathSum)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例: 给定如下二叉树，以及目标和 sum = 22，</p><pre><code class="c">              5             / \            4   8           /   / \          11  13  4         /  \      \        7    2      1</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><p>此处寻找符合条件的路径，可以理解是变量树然后查找其中符合条件的路径。</p><p><strong>方法一：</strong></p><p>递归遍历。使用先序遍历，每次遍历到一个结点就把结点数和上一个相加。符合递归的特性。</p><p>我平时写代码的时候总是不喜欢使用递归，总觉得递归嵌套进去占用内存多。不过现在感觉其实递归代码优美简洁还逻辑清晰，简直不要太猛。</p><p>算法复杂度：<br><em>O ( n )</em></p><p><code>代码如下：</code></p><pre><code class="c">bool hasPathSum(struct TreeNode *root, int sum){    if (root == NULL)    {        return false;    }    else if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)    {        return sum - root-&gt;val == 0;    }    sum -= root-&gt;val;    return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);}</code></pre><p><strong>方法二：</strong></p><pre><code class="c">              5             / \            4   8           /   / \          11  13  4         /  \      \        7    2      1</code></pre><p>两个队列，一个存结点，一个存结点进入后的sum值。算法复杂度也是<em>O ( n )</em>如下：</p><table><thead><tr><th>queueNode：</th><th>5</th><th>4、8</th><th>8、11</th><th>11、13、4</th><th>13、4、7、2</th></tr></thead><tbody><tr><td>queueSum：</td><td>5</td><td>9、13</td><td>13、20</td><td>20、26、17</td><td>26、17、27、22(target)</td></tr></tbody></table><p>其实可以加上剪枝减少计算量。不过这个的算法我没写，如果之后想起来或者重新学到了二叉树的时候再补吧。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> BiTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(01 day)二进制求和(Binary Sum)</title>
      <link href="/2020/06/25/01-day-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C-Binary-Sum/"/>
      <url>/2020/06/25/01-day-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C-Binary-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="01-day-二进制求和-Binary-Sum"><a href="#01-day-二进制求和-Binary-Sum" class="headerlink" title="(01 day)二进制求和(Binary Sum)"></a>(01 day)二进制求和(Binary Sum)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>&emsp;给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0</p><p>示例：  </p><pre><code class="c">input: a = &quot;11&quot;, b = &quot;1&quot;</code></pre><pre><code class="c">output: &quot;100&quot;</code></pre><p>&emsp; 首先想到的是字符串-&gt;十进制数-&gt;求和-&gt;二进制数。但是想到可能使用整数精度不够（对于转换的函数调用也不是很熟练），所以就使用了适合于长度较大的字符串相加计算的方法。类似于大数相加。</p><p>&ensp;11<br>&ensp;&ensp;1<br>——<br>100</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;//char res[100];char* addBinary(char* a, char* b);int main(){    char a[100], b[100];    scanf(&quot;%s %s&quot;, a, b);    printf(&quot;%s&quot;, addBinary(a, b));    return 0;}void reserve(char* a){    int len = strlen(a);    for (int i = 0; i &lt; len / 2; i++)    {        char t;        t = a[i];        a[i] = a[len - 1 - i];        a[len - 1 - i] = t;    }}char* addBinary(char* a, char* b){    char* res;    //char res[100];    int temp = 0, add = 0, carry = 0;    res = (char*)malloc(sizeof(char) * 100);    if (strlen(a) &lt; strlen(b)) //保证函数中a的位数大或等于b    {        return addBinary(b, a);    }    reserve(a);//a，b字符反转    reserve(b);    for (int i = 0; i &lt; strlen(a); i++)    {        if (i &lt; strlen(b))//处理ab相加        {            add = carry + a[i] + b[i] - 2 * &#39;0&#39;; //进位和a[i],b[i]相加        }        else//处理a与进位相加        {            add = carry + a[i] - &#39;0&#39;;        }        temp = add % 2;        carry = add / 2;//进位        res[i] = temp + &#39;0&#39;;    }    if (carry==1)    {        res[strlen(a)] = &#39;1&#39;;        res[strlen(a)+1] = &#39;\0&#39;;    }    else    {        res[strlen(a)] = &#39;\0&#39;;    }    reserve(res);    return res;}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：只遍历了a，b数组一遍。<em>n = max{ |a|   , |b| }</em></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>利用Java和python自带的高精度方法就可以进行直接运算，不过Java中：</p><ul><li>字符超过32位不能使用 Integer</li><li>字符超过65位不能使用 Long</li><li>超过500000001位不能使用BigInteger  </li></ul><p><code>Java</code></p><pre><code class="java">class Solution {    public String addBinary(String a, String b) {        return Integer.toBinaryString(            Integer.parseInt(a, 2) + Integer.parseInt(b, 2)        );    }}</code></pre><p><code>Python</code></p><pre><code class="python">class Solution:    def addBinary(self, a, b) -&gt; str:        return &#39;{0:b}&#39;.format(int(a, 2) + int(b, 2))</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/22/hello-world/"/>
      <url>/2020/06/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
