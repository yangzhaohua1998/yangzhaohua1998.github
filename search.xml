<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>(03 day)跳水板(diving board)</title>
      <link href="/2020/07/08/03-day-%E8%B7%B3%E6%B0%B4%E6%9D%BF-diving-board/"/>
      <url>/2020/07/08/03-day-%E8%B7%B3%E6%B0%B4%E6%9D%BF-diving-board/</url>
      
        <content type="html"><![CDATA[<h1 id="03-day-跳水板-divingBoard"><a href="#03-day-跳水板-divingBoard" class="headerlink" title="(03 day)跳水板(divingBoard)"></a>(03 day)跳水板(divingBoard)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p><p>返回的长度需要从小到大排列。</p><p><strong>示例：</strong></p><pre><code class="c">输入：shorter = 1longer = 2k = 3输出： {3,4,5,6}</code></pre><p>这道题比较简单的。自然而然的想到直接全选最短板。然后一块长板替换一块短板，以此类推。所有就全选最短板 + k个最短板依次换成最长板 = k+1次计算。</p><p>时间复杂度：<em>O ( k + 1 )</em></p><p><strong>代码如下：</strong></p><pre><code class="c">int *divingBoard(int shorter, int longer, int k, int *returnSize){    int *ans;    int size, dvalue;    if (k == 0)    {        *returnSize = 0;        return NULL;    }    else if (shorter == longer)    {        size = 1;        ans = (int *)malloc(sizeof(int));        ans[0] = k * shorter;        *returnSize = size;        return ans;    }    else    {        size = k + 1;        ans = (int *)malloc((k + 1) * sizeof(int));        dvalue = longer - shorter;        ans[0] = shorter * k;        for (int i = 1; i &lt; size; i++)        {            ans[i] = ans[i - 1] + dvalue;        }        *returnSize = k + 1;        return ans;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(02 day)路径求和(path sum)</title>
      <link href="/2020/07/08/02-day-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C-path-sum-1/"/>
      <url>/2020/07/08/02-day-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C-path-sum-1/</url>
      
        <content type="html"><![CDATA[<h1 id="02-day-路径求和-pathSum"><a href="#02-day-路径求和-pathSum" class="headerlink" title="(02 day)路径求和(pathSum)"></a>(02 day)路径求和(pathSum)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例: 给定如下二叉树，以及目标和 sum = 22，</p><pre><code class="c">              5             / \            4   8           /   / \          11  13  4         /  \      \        7    2      1</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><p>此处寻找符合条件的路径，可以理解是变量树然后查找其中符合条件的路径。</p><p><strong>方法一：</strong></p><p>递归遍历。使用先序遍历，每次遍历到一个结点就把结点数和上一个相加。符合递归的特性。</p><p>我平时写代码的时候总是不喜欢使用递归，总觉得递归嵌套进去占用内存多。不过现在感觉其实递归代码优美简洁还逻辑清晰，简直不要太猛。</p><p>算法复杂度：<br><em>O ( n )</em></p><p><code>代码如下：</code></p><pre><code class="c">bool hasPathSum(struct TreeNode *root, int sum){    if (root == NULL)    {        return false;    }    else if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)    {        return sum - root-&gt;val == 0;    }    sum -= root-&gt;val;    return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);}</code></pre><p><strong>方法二：</strong></p><pre><code class="c">              5             / \            4   8           /   / \          11  13  4         /  \      \        7    2      1</code></pre><p>两个队列，一个存结点，一个存结点进入后的sum值。算法复杂度也是<em>O ( n )</em>如下：</p><table><thead><tr><th>queueNode：</th><th>5</th><th>4、8</th><th>8、11</th><th>11、13、4</th><th>13、4、7、2</th></tr></thead><tbody><tr><td>queueSum：</td><td>5</td><td>9、13</td><td>13、20</td><td>20、26、17</td><td>26、17、27、22(target)</td></tr></tbody></table><p>其实可以加上剪枝减少计算量。不过这个的算法我没写，如果之后想起来或者重新学到了二叉树的时候再补吧。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> BiTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(01 day)二进制求和(Binary Sum)</title>
      <link href="/2020/06/25/01-day-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C-Binary-Sum/"/>
      <url>/2020/06/25/01-day-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C-Binary-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="01-day-二进制求和-Binary-Sum"><a href="#01-day-二进制求和-Binary-Sum" class="headerlink" title="(01 day)二进制求和(Binary Sum)"></a>(01 day)二进制求和(Binary Sum)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>&emsp;给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0</p><p>示例：  </p><pre><code class="c">input: a = &quot;11&quot;, b = &quot;1&quot;</code></pre><pre><code class="c">output: &quot;100&quot;</code></pre><p>&emsp; 首先想到的是字符串-&gt;十进制数-&gt;求和-&gt;二进制数。但是想到可能使用整数精度不够（对于转换的函数调用也不是很熟练），所以就使用了适合于长度较大的字符串相加计算的方法。类似于大数相加。</p><p>&ensp;11<br>&ensp;&ensp;1<br>——<br>100</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;//char res[100];char* addBinary(char* a, char* b);int main(){    char a[100], b[100];    scanf(&quot;%s %s&quot;, a, b);    printf(&quot;%s&quot;, addBinary(a, b));    return 0;}void reserve(char* a){    int len = strlen(a);    for (int i = 0; i &lt; len / 2; i++)    {        char t;        t = a[i];        a[i] = a[len - 1 - i];        a[len - 1 - i] = t;    }}char* addBinary(char* a, char* b){    char* res;    //char res[100];    int temp = 0, add = 0, carry = 0;    res = (char*)malloc(sizeof(char) * 100);    if (strlen(a) &lt; strlen(b)) //保证函数中a的位数大或等于b    {        return addBinary(b, a);    }    reserve(a);//a，b字符反转    reserve(b);    for (int i = 0; i &lt; strlen(a); i++)    {        if (i &lt; strlen(b))//处理ab相加        {            add = carry + a[i] + b[i] - 2 * &#39;0&#39;; //进位和a[i],b[i]相加        }        else//处理a与进位相加        {            add = carry + a[i] - &#39;0&#39;;        }        temp = add % 2;        carry = add / 2;//进位        res[i] = temp + &#39;0&#39;;    }    if (carry==1)    {        res[strlen(a)] = &#39;1&#39;;        res[strlen(a)+1] = &#39;\0&#39;;    }    else    {        res[strlen(a)] = &#39;\0&#39;;    }    reserve(res);    return res;}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：只遍历了a，b数组一遍。<em>n = max{ |a|   , |b| }</em></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>利用Java和python自带的高精度方法就可以进行直接运算，不过Java中：</p><ul><li>字符超过32位不能使用 Integer</li><li>字符超过65位不能使用 Long</li><li>超过500000001位不能使用BigInteger  </li></ul><p><code>Java</code></p><pre><code class="java">class Solution {    public String addBinary(String a, String b) {        return Integer.toBinaryString(            Integer.parseInt(a, 2) + Integer.parseInt(b, 2)        );    }}</code></pre><p><code>Python</code></p><pre><code class="python">class Solution:    def addBinary(self, a, b) -&gt; str:        return &#39;{0:b}&#39;.format(int(a, 2) + int(b, 2))</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/22/hello-world/"/>
      <url>/2020/06/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
